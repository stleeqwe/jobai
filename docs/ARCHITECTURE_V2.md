# JobChat 검색 아키텍처 V2

> 2-Stage Hybrid Architecture: DB 필터링 + AI 선별

---

## 1. 기존 아키텍처 문제점

### 1.1 복잡한 Function Calling 기반 필터링

```
기존 흐름:
사용자 입력 → Gemini 파싱 → Function Calling → DB 쿼리 → 결과

문제점:
- job_type 매핑이 복잡 (mvp_category_map 필요)
- 키워드 필터가 무시됨
- "기타" 카테고리 문제 (22%+)
- 새로운 직무 추가 시 매핑 유지보수 필요
```

### 1.2 근본적 한계

| 문제 | 설명 | 영향 |
|------|------|------|
| 직무 다양성 | "AWS 엔지니어", "클라우드 아키텍트" 등 무한한 변형 | 매핑 누락 → "기타" |
| 컨텍스트 손실 | "React 프론트엔드" → job_type만 전달, React 무시 | 부정확한 결과 |
| 과도한 추상화 | 자연어 → 구조화 파라미터 → DB 쿼리 | 정보 손실 |

---

## 2. 새로운 아키텍처: 2-Stage Hybrid

### 2.1 핵심 원칙

```
DB가 잘하는 것: 숫자/범주 필터링 (위치, 연봉, 경력)
AI가 잘하는 것: 자연어 이해 (직무 매칭, 키워드 관련성)

→ 각자 잘하는 것만 담당하게 분리
```

### 2.2 아키텍처 다이어그램

```
┌─────────────────────────────────────────────────────────────────┐
│                      사용자 입력                                  │
│  "강남역 근처 iOS 프론트 앱 개발자 연봉 5천만원 이상 공고 찾아줘"      │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Stage 1: DB 필터링                            │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ Gemini가 명확한 조건만 추출:                              │    │
│  │ - location: ["강남구", "서초구"] (강남역 인근)             │    │
│  │ - salary_min: 5000                                       │    │
│  │ - experience_type: null (미지정)                         │    │
│  └─────────────────────────────────────────────────────────┘    │
│                            │                                     │
│                            ▼                                     │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ Firestore 쿼리:                                          │    │
│  │ - is_active == true                                      │    │
│  │ - location_gugun in ["강남구", "서초구"]                  │    │
│  │ - (연봉 필터는 클라이언트 사이드)                          │    │
│  └─────────────────────────────────────────────────────────┘    │
│                            │                                     │
│                            ▼                                     │
│  결과: ~300건 (10,000건 중 위치+연봉 필터)                        │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Stage 2: AI 선별                              │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ Gemini에게 전달:                                         │    │
│  │ - 사용자 원본 요청: "iOS 프론트 앱 개발자"                 │    │
│  │ - 후보 공고 목록 (300건):                                 │    │
│  │   [{ id, title, company, job_type_raw }, ...]           │    │
│  └─────────────────────────────────────────────────────────┘    │
│                            │                                     │
│                            ▼                                     │
│  ┌─────────────────────────────────────────────────────────┐    │
│  │ Gemini 판단:                                             │    │
│  │ "iOS 프론트 앱 개발자"에 해당하는 공고 선별:               │    │
│  │ - "iOS 개발자 채용" ✓                                    │    │
│  │ - "앱 개발 (Flutter/React Native)" ✓                    │    │
│  │ - "모바일 앱 프론트엔드 개발자" ✓                         │    │
│  │ - "백엔드 개발자" ✗                                      │    │
│  │ - "웹 프론트엔드 개발자" ✗ (웹이라 제외)                  │    │
│  └─────────────────────────────────────────────────────────┘    │
│                            │                                     │
│  결과: 관련 있는 모든 공고 ID 목록 반환                          │
└───────────────────────────┬─────────────────────────────────────┘
                            │
                            ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Stage 3: 결과 반환                            │
│  - AI가 선별한 모든 공고를 반환                                   │
│  - 페이지네이션 적용 (한 페이지 20건)                             │
│  - 클라이언트에서 추가 정렬/필터 가능                             │
└─────────────────────────────────────────────────────────────────┘
```

---

## 3. 상세 설계

### 3.1 Stage 1: DB 필터링

**목적**: 전체 데이터에서 명확한 조건으로 후보군 축소

**필터링 대상 (DB에서 처리)**:
| 조건 | Firestore 쿼리 | 예시 |
|------|---------------|------|
| 위치 | `location_gugun in [...]` | 강남구, 서초구 |
| 연봉 | 클라이언트 필터 | salary_min >= 5000 |
| 경력 | `experience_type in [...]` | 신입, 경력무관 |
| 고용형태 | `employment_type == ...` | 정규직 |

**필터링 제외 (AI에게 위임)**:
- job_type (직무)
- job_keywords (키워드)
- 직무 카테고리

**예상 결과**:
- 전체: 10,000건
- Stage 1 후: 100~500건 (위치+연봉 필터)

### 3.2 Stage 2: AI 선별

**목적**: 후보군에서 사용자 의도에 맞는 공고 선별

**입력 데이터 (토큰 최적화)**:
```json
{
  "user_request": "iOS 프론트 앱 개발자",
  "candidates": [
    {"id": "jk_123", "title": "iOS 개발자 채용", "job_type_raw": "모바일개발"},
    {"id": "jk_456", "title": "백엔드 개발자", "job_type_raw": "서버개발"},
    ...
  ]
}
```

**AI 프롬프트**:
```
다음 후보 공고 목록에서 사용자 요청에 관련 있는 공고만 선별하세요.

사용자 요청: "{user_request}"

후보 공고:
{candidates를 번호 목록으로}

관련 있는 공고의 ID만 배열로 반환하세요.
응답 형식: ["jk_123", "jk_789", ...]
```

**출력**:
```json
["jk_123", "jk_789", "jk_234", ...]
```

### 3.3 Stage 3: 결과 조합

**흐름**:
1. AI가 선별한 ID 목록 수신
2. 해당 ID들의 전체 데이터 조회 (이미 Stage 1에서 가져온 데이터 활용)
3. 페이지네이션 적용하여 반환

**페이지네이션**:
- 페이지당 20건
- 총 결과 수 함께 반환
- 무한 스크롤 또는 페이지 네비게이션 지원

---

## 4. Function Calling 단순화

### 4.1 기존 (복잡)

```python
SEARCH_JOBS_FUNCTION = {
    "name": "search_jobs",
    "parameters": {
        "job_type": "...",           # 복잡한 매핑 필요
        "job_category": "...",       # mvp_category_map 필요
        "job_keywords": [...],       # 무시됨
        "preferred_locations": [...],
        "salary_min": ...,
        ...
    }
}
```

### 4.2 새로운 (단순)

```python
# Stage 1용 (DB 필터만)
FILTER_JOBS_FUNCTION = {
    "name": "filter_jobs",
    "description": "명확한 조건으로 DB에서 후보 공고를 필터링합니다",
    "parameters": {
        "locations": {
            "type": "array",
            "items": {"type": "string"},
            "description": "위치 필터 (구/군 단위)"
        },
        "salary_min": {
            "type": "integer",
            "description": "최소 연봉 (만원)"
        },
        "experience_type": {
            "type": "string",
            "enum": ["신입", "경력", "경력무관"],
            "description": "경력 조건"
        },
        "employment_type": {
            "type": "string",
            "enum": ["정규직", "계약직", "인턴", "프리랜서"],
            "description": "고용형태"
        }
    }
}

# Stage 2는 프롬프트 기반 (Function Calling 불필요)
```

---

## 5. 토큰 효율성 분석

### 5.1 후보 300건 기준

**입력 토큰 추정**:
```
- 시스템 프롬프트: ~200 토큰
- 사용자 요청: ~50 토큰
- 후보 목록 (300건 × 30토큰): ~9,000 토큰
───────────────────────────────
총 입력: ~9,250 토큰
```

**출력 토큰 추정**:
```
- 선별된 ID 배열 (50건 × 15토큰): ~750 토큰
───────────────────────────────
총 출력: ~750 토큰
```

**비용 추정** (Gemini 2.5 Flash-Lite 기준):
- 입력: $0.075 / 1M 토큰 → $0.0007/요청
- 출력: $0.30 / 1M 토큰 → $0.0002/요청
- **총: ~$0.001/요청 (≈ 1원)**

### 5.2 최적화 옵션

후보가 너무 많을 경우:
1. **배치 처리**: 300건을 100건씩 3배치로
2. **필드 최소화**: id + title만 전달 (job_type_raw 생략)
3. **사전 필터**: DB에서 최근 30일 공고만 가져오기

---

## 6. 구현 계획

### Phase 1: 백엔드 리팩토링 (P1)

**파일**: `backend/app/services/gemini.py`

변경 내용:
1. `SEARCH_JOBS_FUNCTION` → `FILTER_JOBS_FUNCTION` 변경
2. Stage 2 AI 선별 로직 추가
3. 프롬프트 단순화

**파일**: `backend/app/services/job_search.py`

변경 내용:
1. `search_jobs_in_db()` → `filter_jobs_by_conditions()` 리팩토링
2. job_type 필터 제거 (AI에게 위임)
3. 페이지네이션 지원 추가

### Phase 2: 프론트엔드 업데이트 (P2)

**파일**: `frontend/src/hooks/useChat.ts`

변경 내용:
1. 페이지네이션 상태 관리
2. "더 보기" 또는 페이지 네비게이션 UI

### Phase 3: 테스트 및 튜닝 (P3)

1. E2E 테스트 시나리오 실행
2. AI 선별 정확도 측정
3. 프롬프트 최적화

---

## 7. 예상 효과

| 지표 | 기존 | 새 아키텍처 | 개선 |
|------|------|------------|------|
| 직무 매칭 정확도 | ~40% | >85% | +45% |
| "기타" 문제 | 22%+ | 0% | 해결 |
| 키워드 반영 | 0% | >80% | 신규 |
| 유지보수 복잡도 | 높음 | 낮음 | 개선 |
| 응답 시간 | ~1초 | ~1.5초 | 약간 증가 |
| 비용/요청 | ~$0.0005 | ~$0.001 | 2배 |

**Trade-off**: 응답 시간과 비용이 약간 증가하지만, 정확도가 크게 향상됨

---

## 8. 롤백 계획

문제 발생 시:
1. Stage 2 AI 선별을 비활성화
2. Stage 1 결과를 직접 반환 (기존 방식과 유사)
3. 점진적으로 AI 선별 비율 조절 (A/B 테스트)

---

## 변경 이력

- **2026-01-13**: V2 아키텍처 설계 (2-Stage Hybrid)
