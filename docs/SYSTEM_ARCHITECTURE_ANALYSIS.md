# JobBot 시스템 아키텍처 분석 보고서

**분석일**: 2026-01-17
**버전**: V6 (Simple Agentic)
**분석 목적**: 직무 매칭 정확도 문제의 근본 원인 파악

---

## 1. 전체 시스템 아키텍처

```
┌─────────────────────────────────────────────────────────────────────────┐
│                           JobBot 데이터 흐름                              │
└─────────────────────────────────────────────────────────────────────────┘

┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│   크롤러     │───▶│  Firestore  │───▶│   백엔드    │───▶│  프론트엔드  │
│  (수집/저장) │    │    (DB)     │    │ (검색/AI)   │    │   (표시)    │
└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘
      │                  │                  │                  │
      ▼                  ▼                  ▼                  ▼
┌─────────────┐    ┌─────────────┐    ┌─────────────┐    ┌─────────────┐
│ job_keywords│    │ 51,000건    │    │ Gemini LLM  │    │ 사용자 입력 │
│ 생성        │    │ 서울 공고   │    │ + 매칭 로직  │    │ + 결과 표시 │
└─────────────┘    └─────────────┘    └─────────────┘    └─────────────┘
```

---

## 2. 단계별 상세 흐름

### 2.1 크롤러 단계 (데이터 수집)

```
잡코리아 상세페이지 HTML
        │
        ▼
┌───────────────────────────────────────┐
│        detail_parser.py               │
│  ┌─────────────────────────────────┐  │
│  │ 1. _parse_title()               │  │
│  │    - JSON-LD / CSS / og:title   │  │
│  │    - 결과: title                 │  │
│  └─────────────────────────────────┘  │
│  ┌─────────────────────────────────┐  │
│  │ 2. _parse_work_fields()         │  │
│  │    - 정규식: workFields 배열     │  │
│  │    - 결과: ["백엔드", "Python"]  │  │
│  └─────────────────────────────────┘  │
│  ┌─────────────────────────────────┐  │
│  │ 3. _parse_skills()              │  │
│  │    - 정규식: HARD_SKILL 타입     │  │
│  │    - 결과: ["Python", "Django"] │  │
│  └─────────────────────────────────┘  │
│  ┌─────────────────────────────────┐  │
│  │ 4. _build_keywords()            │  │
│  │    - 우선순위: skills > work    │  │
│  │      > title_tokens             │  │
│  │    - 불용어 제거, 중복 제거      │  │
│  │    - 결과: job_keywords[]       │  │
│  └─────────────────────────────────┘  │
└───────────────────────────────────────┘
        │
        ▼
┌───────────────────────────────────────┐
│           Firestore 저장              │
│  {                                    │
│    "title": "Python 백엔드 개발자",   │
│    "job_type_raw": "백엔드, Python",  │
│    "job_keywords": [                  │
│      "Python", "Django", "PostgreSQL",│
│      "백엔드", "개발자"               │
│    ]                                  │
│  }                                    │
└───────────────────────────────────────┘
```

**핵심 포인트**:
- `job_keywords` = skills + work_fields + title_tokens (순서대로, 중복 제거)
- 불용어 제거: "채용", "모집", "신입" 등
- **문제점 A**: 정규식 실패 시 빈 배열 가능

---

### 2.2 AI 분류 단계 (사용자 쿼리 분석)

```
사용자: "프론트엔드 개발자 5000만원 이상"
        │
        ▼
┌───────────────────────────────────────┐
│           Gemini LLM                  │
│  ┌─────────────────────────────────┐  │
│  │ System Prompt 지시:             │  │
│  │ "동의어, 유사 직무명, 영문/한글  │  │
│  │  변형을 모두 포함하세요"         │  │
│  │                                  │  │
│  │ 예시:                           │  │
│  │ "프론트엔드 개발자" →            │  │
│  │ ["프론트엔드개발자", "프론트엔드",│  │
│  │  "Frontend", "웹개발", "React",  │  │
│  │  "Vue", "Angular", ...]          │  │
│  └─────────────────────────────────┘  │
│                                       │
│  ┌─────────────────────────────────┐  │
│  │ 자율 판단:                       │  │
│  │ - 직무 + 연봉 있음 → search_jobs │  │
│  │ - 정보 부족 → 재질문              │  │
│  └─────────────────────────────────┘  │
└───────────────────────────────────────┘
        │
        ▼
search_jobs 호출:
{
  "job_keywords": ["프론트엔드", "Frontend", "웹개발", "React", ...],
  "salary_min": 5000,
  "company_location": "",
  "commute_max_minutes": 60
}
```

**핵심 포인트**:
- LLM이 **자율적으로** 키워드 확장
- 프롬프트 지시에 따라 동의어/기술스택 포함
- **문제점 B**: 과도한 키워드 확장 가능 (React, Vue 등은 프론트엔드에 국한되지 않을 수 있음)

---

### 2.3 백엔드 검색 단계 (DB 매칭)

```
search_jobs_with_commute() 호출
        │
        ▼
┌───────────────────────────────────────┐
│        _filter_from_db()              │
│  ┌─────────────────────────────────┐  │
│  │ 1. Firestore 기본 쿼리           │  │
│  │    jobs.where(is_active == True) │  │
│  │    .limit(20000)                 │  │
│  └─────────────────────────────────┘  │
│  ┌─────────────────────────────────┐  │
│  │ 2. Python 메모리 필터링           │  │
│  │    For each job:                 │  │
│  │      score = calculate_match()   │  │
│  │      if score <= 1: continue     │  │
│  │      if not salary_match: skip   │  │
│  │      if not location_match: skip │  │
│  └─────────────────────────────────┘  │
└───────────────────────────────────────┘
        │
        ▼
┌───────────────────────────────────────┐
│      keyword_matcher.py               │
│  ┌─────────────────────────────────┐  │
│  │ calculate_match_score()          │  │
│  │                                  │  │
│  │ 가중치:                          │  │
│  │   title 매칭     → +3점          │  │
│  │   job_type 매칭  → +2점          │  │
│  │   job_keywords   → +1점          │  │
│  │                                  │  │
│  │ 필터: score > 1 (최소 2점)       │  │
│  │ → title 또는 job_type 필수       │  │
│  └─────────────────────────────────┘  │
└───────────────────────────────────────┘
        │
        ▼
┌───────────────────────────────────────┐
│        매칭 방식 상세                  │
│                                       │
│ 검색어: ["프론트엔드", "React", ...]  │
│                                       │
│ 공고 A: "React 개발자"                 │
│   - title: "프론트엔드" 없음          │
│   - title: "React" 있음 → +3          │
│   - job_type: 확인...                 │
│   - score >= 3 ✓ 포함                 │
│                                       │
│ 공고 B: "React Native 개발자"         │
│   - title: "React" 있음 → +3          │
│   - score >= 3 ✓ 포함                 │
│   ※ React Native는 모바일 개발!      │
│                                       │
│ 공고 C: "Java 백엔드 개발자"          │
│   - title: "프론트엔드" 없음          │
│   - title: "React" 없음               │
│   - job_keywords에 "개발자" 있음 → +1 │
│   - score = 1 ✗ 제외                  │
└───────────────────────────────────────┘
```

**핵심 포인트**:
- 검색어 간 **OR** 관계 (하나라도 매칭되면 포함)
- 필드 간 **AND 누적** (가중치 합산)
- 부분 문자열 매칭 ("React" ⊆ "React Native")
- **문제점 C**: substring 매칭으로 의도치 않은 공고 포함

---

## 3. 핵심 필드 스키마

### 3.1 크롤러 → DB 저장 필드

| 필드명 | 타입 | 설명 | 검색 사용 |
|--------|------|------|-----------|
| `title` | string | 공고 제목 | ✓ 3점 |
| `job_type_raw` | string | 원본 직무분류 | ✓ 2점 |
| `job_keywords` | array | 추출된 키워드 | ✓ 1점 |
| `location_gugun` | string | 구 단위 위치 | 위치 필터 |
| `location_full` | string | 전체 주소 | 위치 필터 |
| `salary_min` | int | 최소 연봉 (만원) | 연봉 필터 |
| `salary_max` | int | 최대 연봉 (만원) | 연봉 필터 |
| `is_active` | bool | 활성 여부 | DB 쿼리 |

### 3.2 AI 생성 → 백엔드 검색 파라미터

| 필드명 | 타입 | 설명 | 필수 |
|--------|------|------|------|
| `job_keywords` | array | LLM이 확장한 키워드 | ✓ |
| `salary_min` | int | 최소 연봉 (만원) | ✓ |
| `salary_max` | int | 최대 연봉 | |
| `company_location` | string | 회사 위치 | |
| `commute_max_minutes` | int | 최대 통근시간 | |

---

## 4. 문제점 분석

### 4.1 문제점 A: 크롤러 데이터 품질

**발생 지점**: `crawler/app/parsers/detail_parser.py`

**증상**:
- `job_keywords`가 빈 배열 `[]`인 공고 존재
- 정규식 실패 시 skills/work_fields 누락

**원인**:
```python
# 복잡한 정규식 - 실패 가능성 높음
skills_pattern = re.compile(
    r'\\?"name\\?":\\?"([^"\\]+)\\?",\\?"rank\\?":\d+,'
    r'\\?"manualInput\\?":(true|false),\\?"skillTypeCode\\?":\\?"HARD_SKILL\\?"'
)
```

**사용자 영향**:
- 검색 시 해당 공고가 누락될 수 있음
- 특히 skills 기반 검색 정확도 저하

**발생 빈도**: 약 10-20% (정규식 실패 시)

---

### 4.2 문제점 B: AI 키워드 과확장

**발생 지점**: `backend/app/prompts/system_prompt.txt`

**증상**:
- "프론트엔드 개발자" 검색 시 React, Vue, Angular 등 모두 확장
- 확장된 키워드가 다른 직군 공고와도 매칭

**원인** (프롬프트 지시):
```
job_keywords: 직무 키워드 (필수)
  - 동의어, 유사 직무명, 영문/한글 변형을 모두 포함하세요
  - 예: "프론트엔드 개발자" → ["프론트엔드", "Frontend", "React", "Vue", ...]
```

**사용자 시나리오**:
```
사용자: "프론트엔드 개발자 찾아줘"

AI 생성 키워드:
["프론트엔드", "Frontend", "React", "Vue", "Angular", "웹개발", ...]

문제 발생:
- "React Native 개발자" (모바일) → "React" 매칭 ✓ → 포함됨
- "Vue.js 풀스택 개발자" → "Vue" 매칭 ✓ → 포함됨
- 사용자가 원한 "웹 프론트엔드"와 다른 결과 혼재
```

**사용자 영향**: **높음**
- 검색 결과에 관련성 낮은 공고 포함
- 사용자 신뢰도 저하

---

### 4.3 문제점 C: 부분 문자열 매칭

**발생 지점**: `backend/app/utils/keyword_matcher.py`

**증상**:
- "백엔드" 검색 시 "백엔드" 포함된 모든 공고 매칭
- "개발" 검색 시 "개발", "개발자", "웹개발", "앱개발" 모두 매칭

**원인**:
```python
def _matches_text(nk: NormalizedKeyword, text: str, text_no_space: str) -> bool:
    return (
        nk.lower in text or           # substring 매칭
        nk.no_space in text or
        nk.no_space in text_no_space
    )
```

**문제 시나리오**:
```
검색 키워드: ["프론트엔드"]

공고 title: "프론트엔드/백엔드 풀스택 개발자"
→ "프론트엔드" ⊆ "프론트엔드/백엔드 풀스택 개발자" ✓
→ 포함됨 (하지만 사용자는 순수 프론트엔드 원함)

공고 title: "프론트엔드 개발 인턴"
→ "프론트엔드" ⊆ "프론트엔드 개발 인턴" ✓
→ 포함됨 (정확 매칭)
```

**사용자 영향**: **중간**
- 결과 정확도 저하
- 상위 정렬로 일부 완화됨

---

### 4.4 문제점 D: job_keywords 양방향 매칭

**발생 지점**: `backend/app/utils/keyword_matcher.py`

**증상**:
- 공고의 job_keywords에 짧은 키워드가 있으면 많은 검색에 매칭

**원인**:
```python
def _matches_job_keywords(nk: NormalizedKeyword, job_keywords: Set[str]) -> bool:
    for jk in job_keywords:
        if nk.lower in jk or nk.no_space in jk or \
           jk in nk.lower or jk in nk.no_space:  # 양방향!
            return True
    return False
```

**문제 시나리오**:
```
검색 키워드: ["python developer"]

공고 job_keywords: ["py", "backend"]
→ "py" ⊆ "python developer" (양방향) ✓
→ job_keywords 매칭! (+1점)
→ 단, score=1이므로 현재는 제외됨 (score > 1 조건)
```

**사용자 영향**: **낮음** (현재 score > 1 조건으로 완화됨)

---

### 4.5 문제점 E: 검색어 OR 관계

**발생 지점**: `backend/app/utils/keyword_matcher.py`

**증상**:
- 여러 키워드 중 하나라도 매칭되면 결과에 포함
- AI가 많은 키워드를 생성할수록 결과가 넓어짐

**원인**:
```python
for keyword in keywords:  # OR 관계
    if _matches_text(nk, job_text.title, ...):
        title_matched = True  # 하나만 매칭돼도 True
```

**문제 시나리오**:
```
AI 생성 키워드: ["프론트엔드", "React", "Vue", "Angular", "JavaScript", "TypeScript", "웹개발", "웹퍼블리셔", ...]

결과:
- 10개 키워드 중 1개만 매칭돼도 포함
- "JavaScript" 매칭 → 백엔드 Node.js 공고도 포함
- "웹개발" 매칭 → 풀스택 공고도 포함
```

**사용자 영향**: **높음**
- 검색 결과가 너무 넓어짐
- 관련성 낮은 공고 다수 포함

---

## 5. 문제점 종합 영향도

```
┌──────────────────────────────────────────────────────────────────┐
│                    문제점 발생 위치 맵                             │
└──────────────────────────────────────────────────────────────────┘

크롤러          AI 분류         백엔드 검색         사용자 경험
─────────      ─────────       ───────────        ───────────
   │               │                │                  │
   │               │                │                  │
[문제점 A]         │                │                  │
job_keywords      │                │               ▼──────▼
빈 배열 가능  ────┼────────────────┼──────────────▶ 공고 누락
                  │                │
               [문제점 B]          │
               키워드 과확장  ──────┼──────────────▶ 무관 공고
                  │                │                 포함
                  │           [문제점 C]
                  │           부분문자열 ──────────▶ 부정확
                  │           매칭                   매칭
                  │                │
                  │           [문제점 D]
                  │           양방향 매칭 ─────────▶ 과매칭
                  │           (완화됨)
                  │                │
                  └────────── [문제점 E]
                              OR 관계 ─────────────▶ 결과 넓어짐
```

---

## 6. 사용자 시나리오별 영향

### 시나리오 1: 정확한 직무 검색

**입력**: "프론트엔드 개발자 연봉 5000만원 이상"

**기대 결과**: 순수 프론트엔드 웹 개발자 공고만

**실제 결과**:
- ✅ 프론트엔드 개발자 공고 (정확 매칭)
- ⚠️ React Native 개발자 (모바일)
- ⚠️ 풀스택 개발자 (프론트+백엔드)
- ⚠️ 웹 퍼블리셔 (디자인 중심)

**영향도**: 중간 (상위 정렬로 정확 매칭이 먼저 표시됨)

---

### 시나리오 2: 기술스택 기반 검색

**입력**: "Python 개발자 연봉 4000만원 이상"

**기대 결과**: Python 사용 개발자 공고

**실제 결과**:
- ✅ Python 백엔드 개발자
- ✅ Django 개발자
- ⚠️ 데이터 엔지니어 (Python 사용)
- ⚠️ 머신러닝 엔지니어 (Python 사용)
- ⚠️ 자동화 QA (Python 테스트)

**영향도**: 낮음 (기술스택 검색은 원래 넓은 범위)

---

### 시나리오 3: 특정 직군 검색

**입력**: "UI/UX 디자이너 연봉 5000만원 이상"

**기대 결과**: UI/UX 디자이너 공고

**실제 결과**:
- ✅ UI/UX 디자이너
- ⚠️ 프로덕트 디자이너 (UI/UX 포함)
- ⚠️ 웹 디자이너 (UI 중심)
- ❌ 그래픽 디자이너 (무관)

**영향도**: 중간

---

### 시나리오 4: 희귀 직군 검색

**입력**: "데이터 분석가 연봉 4000만원 이상"

**기대 결과**: 데이터 분석가/애널리스트 공고

**실제 결과**:
- ⚠️ 데이터 엔지니어 (분석 아님)
- ⚠️ 비즈니스 분석가 (다른 분야)
- ❌ 정확한 "데이터 분석가" 공고 부족

**영향도**: 높음 (DB에 해당 공고 자체가 적을 수 있음)

---

## 7. 서비스 품질 영향 정량화

### 7.1 테스트 결과 비교

| 측정 방식 | 정확도 | 설명 |
|-----------|--------|------|
| 타이틀 키워드 분석 (엄격) | 14% | 타이틀에 정확한 키워드 포함 |
| 품질 총괄 테스트 (실용적) | 100% | 상위 5건 수동 검증 |

### 7.2 해석

**정확도 14%의 의미**:
- 상위 20건 중 약 3건만 타이틀에 정확한 키워드 포함
- 나머지 17건은 title 외 필드(job_type, job_keywords)로 매칭
- 또는 확장된 키워드(React, Vue 등)로 매칭

**품질 테스트 100%의 의미**:
- 상위 5건은 관련성 있는 공고
- 정렬 우선순위 (title 매칭 3점)가 효과적
- 사용자가 주로 보는 상위 결과는 양호

### 7.3 결론

```
┌─────────────────────────────────────────────────────────────┐
│                    서비스 품질 평가                          │
├─────────────────────────────────────────────────────────────┤
│  상위 5건 정확도:  ████████████████████ 100% (양호)        │
│  상위 20건 정확도: ███░░░░░░░░░░░░░░░░░  20% (개선 필요)   │
│  전체 결과 정확도: ██░░░░░░░░░░░░░░░░░░  14% (문제 있음)   │
├─────────────────────────────────────────────────────────────┤
│  사용자 체감:      ████████░░░░░░░░░░░░  양호~보통         │
│  (상위 결과 중심 사용 시)                                    │
└─────────────────────────────────────────────────────────────┘
```

---

## 8. 개선 방향 제안

### 8.1 단기 개선 (Quick Wins)

#### A. AI 키워드 생성 제한
```
현재: 프롬프트에서 "모든 동의어 포함" 지시
개선: 핵심 키워드 3-5개로 제한 + 기술스택 분리
```

#### B. 매칭 점수 임계값 상향
```
현재: score > 1 (job_type 2점 또는 title 3점)
개선: score >= 3 (title 매칭 필수)
```

#### C. 네거티브 키워드 도입
```
검색: "프론트엔드 개발자"
제외: ["백엔드", "풀스택", "모바일", "Native"]
```

### 8.2 중기 개선

#### D. 직무 카테고리 도입
```
크롤러: job_category 필드 추가 ("프론트엔드", "백엔드", ...)
검색: 카테고리 기반 1차 필터링 후 키워드 매칭
```

#### E. TF-IDF 또는 유사도 기반 랭킹
```
현재: Boolean 매칭 (있다/없다)
개선: 키워드 중요도 가중치 적용
```

### 8.3 장기 개선

#### F. 벡터 검색 (Semantic Search)
```
공고 임베딩 + 쿼리 임베딩 → 코사인 유사도
의미적으로 유사한 공고 검색
```

---

## 9. 파일 위치 총정리

| 구분 | 파일 | 핵심 라인 | 역할 |
|------|------|-----------|------|
| 크롤러 | `crawler/app/parsers/detail_parser.py` | 308-347 | job_keywords 생성 |
| 크롤러 | `crawler/app/db/firestore.py` | 116-137 | DB 저장 |
| AI | `backend/app/prompts/system_prompt.txt` | 전체 | 키워드 확장 지시 |
| AI | `backend/app/services/gemini.py` | 55-115 | Function 정의 |
| 검색 | `backend/app/services/job_search.py` | 102-165 | DB 필터링 |
| 검색 | `backend/app/utils/keyword_matcher.py` | 97-156 | 점수 계산 |
| 검색 | `backend/app/utils/filters.py` | 10-195 | 연봉/위치 필터 |

---

## 10. 결론

### 현재 상태
- **상위 결과 품질**: 양호 (정렬 우선순위 효과)
- **전체 결과 정확도**: 개선 필요 (14%)
- **주요 원인**: AI 키워드 과확장 + OR 기반 매칭

### 우선 조치
1. AI 프롬프트 수정: 핵심 키워드 제한
2. 매칭 임계값 상향: score >= 3
3. 네거티브 키워드 도입

### 기대 효과
- 상위 20건 정확도: 20% → 50%+
- 전체 결과 정확도: 14% → 30%+
- 사용자 체감 품질 향상

---

**작성자**: Claude Opus 4.5 (품질 총괄 디렉터)
**검토일**: 2026-01-17
